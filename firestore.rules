/**
 * Core Philosophy: This ruleset establishes a hybrid security model for an e-commerce platform.
 * It provides public read-only access to catalog data (products, categories, and reviews) while
 * enforcing a strict user-ownership model for all personal user data (profiles, shopping carts, orders).
 * This allows anonymous users to browse the catalog freely but requires authentication for any
 * action that involves personal data or transactions.
 *
 * Data Structure:
 * - Public data is stored in top-level collections like `/products` and `/categories`.
 * - Product-specific public data, like reviews, is nested under the relevant product: `/products/{productId}/reviews`.
 * - All private user data is strictly segregated and nested under a path dedicated to that user: `/users/{userId}`.
 *   This includes subcollections for `/cart_items` and `/orders`.
 *
 * Key Security Decisions:
 * - Admin-Only Writes: All catalog data (products, categories) is read-only for clients.
 *   These collections must be managed by a trusted backend server or admin SDK.
 * - User-Generated Content: Users can create, update, and delete their own product reviews.
 *   Ownership is enforced via a `userId` field on each review document.
 * - Immutable Orders: Once an order is created by a user, it cannot be modified or deleted by the client.
 *   This ensures data integrity for historical transactions.
 * - No User Listing: The top-level `/users` collection cannot be listed by any client to protect user privacy.
 * - Unsecurable Path: The `/orders/{orderId}/order_items` path is locked down entirely. The structure is
 *   unsecurable because it's impossible to link an `order_item` back to a user owner without performing
 *   a cross-collection query, which is not supported in security rules. This collection should be
 *   nested under `/users/{userId}/orders/{orderId}` to be secure.
 *
 * Denormalization for Authorization:
 * - Path-Based Ownership: The primary authorization mechanism is path-based. Any document under `/users/{userId}/...`
 *   inherits ownership from the `userId` in the path, enabling fast, simple rules without extra database reads (`get` calls).
 * - Embedded Ownership: For public collections with user-generated content (e.g., `/products/.../reviews`), an ownership field
 *   (e.g., `userId`) is denormalized directly onto the document. This allows rules to verify ownership for writes
 *   (`resource.data.userId == request.auth.uid`) without needing to read a separate document.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the core function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update/delete.
     * Prevents operations on documents that do not exist.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the incoming document's userId matches the path owner.
     * Enforces relational integrity on document creation.
     */
    function incomingDataMatchesOwner(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Validates that critical relational IDs are not being changed on update.
     */
    function ownerIdIsImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }


    /**
     * @description Publicly readable product categories. Writes are disabled from clients.
     * @path /categories/{categoryId}
     * @allow (get) An unauthenticated user can read a specific category.
     * @deny (create) Any user attempting to create a new category.
     * @principle Segregates public data into a read-only collection for all users.
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Publicly readable product data. Writes are disabled from clients.
     * @path /products/{productId}
     * @allow (get) An unauthenticated user can read a specific product's details.
     * @deny (create) Any user attempting to create a new product.
     * @principle Segregates public data into a read-only collection for all users.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Product reviews are public to read, but a user can only create, update, or delete their own reviews.
     * @path /products/{productId}/reviews/{reviewId}
     * @allow (create) auth.uid='user123' creates a review with { userId: 'user123', productId: 'prodABC' }.
     * @deny (update) auth.uid='user456' tries to update a review where the existing `userId` is 'user123'.
     * @principle Implements the "Public Read, Owner-Only Write" pattern using a denormalized `userId` field.
     */
    match /products/{productId}/reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn()
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.productId == productId;
      allow update: if isSignedIn()
                      && resource.data.userId == request.auth.uid
                      && request.resource.data.userId == resource.data.userId
                      && request.resource.data.productId == resource.data.productId;
      allow delete: if isSignedIn() && resource != null && resource.data.userId == request.auth.uid;
    }

    /**
     * @description A user's own profile document.
     * @path /users/{userId}
     * @allow (create) auth.uid='user123' creates their own profile at /users/user123.
     * @deny (get) auth.uid='user456' tries to read /users/user123.
     * @deny (list) Any user tries to list the /users collection.
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Explicitly deny listing all users
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description A user's private shopping cart.
     * @path /users/{userId}/cart_items/{cartItemId}
     * @allow (create) auth.uid='user123' adds an item to their own cart at /users/user123/cart_items/...
     * @deny (get) auth.uid='user456' tries to read an item from user123's cart.
     * @principle Enforces strict document ownership within a user's private data subcollection.
     */
    match /users/{userId}/cart_items/{cartItemId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingDataMatchesOwner(userId);
      allow update: if isExistingOwner(userId) && ownerIdIsImmutable();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description A user's private order history. Orders are immutable from the client once created.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) auth.uid='user123' creates an order in their own history at /users/user123/orders/...
     * @deny (update) auth.uid='user123' tries to update an order they already placed.
     * @principle Enforces ownership and ensures the integrity of historical transaction data by disallowing client modifications.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && incomingDataMatchesOwner(userId);
      allow update: if false; // Orders are immutable
      allow delete: if false; // Orders cannot be deleted
    }

    /**
     * @description CRITICAL: This path is insecure by design and is completely locked down.
     * @path /orders/{orderId}/order_items/{orderItemId}
     * @allow (none) All operations are denied.
     * @deny (get) Any user attempts to read an order item.
     * @principle Prevents access to a collection where ownership cannot be securely determined. The rules cannot
     *           verify which user owns the parent order of an item at this path. To fix this, nest order_items
     *           under the user's order: /users/{userId}/orders/{orderId}/order_items/{orderItemId}.
     */
    match /orders/{orderId}/order_items/{orderItemId} {
      allow read: if false;
      allow write: if false;
    }
  }
}